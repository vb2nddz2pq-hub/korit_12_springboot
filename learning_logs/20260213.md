## Gradle
 - 저희가 Java 초창기에 수업할때 Build system을 설정한 적이 있습니다 여기서 저희는 springBoot와의 연관성을 위해서 Gradle을적용했었습니다
- Maven : mvn 검색할 떄 본 적 있습니다 둘 다 Build System에 해당되는데 Gradle이 좀 더 빠르고 유연합니다

Gradle의 구성(Config) 파일을 build.gradle에서 수행됩니다
프로젝트의 요구 사항에 맞게 사용자가 지정 가능하며 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 프로젝트의 의존성에 대한 정보를 포함합니다 그래서 어제 devtools / lombok / web / h2 와 같은 부분들을 build.gradle -> dependencies에 정의되어 있었습니다. 
```
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.11-SNAPSHOT'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.temp'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
	maven { url = 'https://repo.spring.io/snapshot' }
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

	runtimeOnly  'com.h2database:h2'
}

tasks.named('test') {
	useJUnitPlatform()
}
```

## build.gradle의 일방적인 파일 항목 목록
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에 쓰이는 Gradle플러그인을 정의하는 곳으로, springboot버전을 정의합니다
2. 리포지토리(repositories) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의합니다 저희는 gradle이 의존성을가지고 오기 위해 Maven Central 리포지토리를 이용했습니다(start.spring.io에서 자동 생성함)
3. 의존성(dependencies) : 프로젝트에서 이용되는 의존성을 지정
4. 태스크(taks) : 테스트 등의 빌드 프로세스의 일부를 정의함

# 스프링 이니셜라이저 활용 프로젝트 생성(spring Initializr)

1. https://start.spring.io
2. 의존성
 - Spring Boot DebTools : 자동 재시작 기능을 제공하는 개발자 도구 포함 / 변경 내용을 저장할 때마다 애플리케이션이 자동 다시 실행됩니다
 
  - Spring Boot Starter Web : 풀스택 개발을 위한 옵션으로 자체 내장 톰캣 서버를 제공합니다(옛날 스프링시절에는 server 설정을 하나하나 다 잡아줘야 했습니다 )

# main  단계에서의 springboot 프로젝트의 에너테이션
1. `@EnableAutoConfiguration` : 스프링부트의 자동 구성을 활성화 프로젝트가 의존성에 따라 자동으로 구성됩니다(우리가추가 설정할 필요없이) 예를 들어서 spring-boot-starter-web 의존성이 있는 경우 스프링부트는 우리가 웹 애플리케이션을 개발 중이라고 인식하고 그에 따라 애플리케이션 구성을 가집니다

2. `@ComponentScan` : 스프링부트 컴포넌트 검색으로, 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 합니다(Component 개념은 추후 설명)
3. `@Configuration` : 빈(bean) 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정.

## 로그 및 문제 해결
1. Logging은  애플리케이션의 흐름을 모니터링하는데 이용할 수 있고, 오류를 포착하는 방식입니다.스타터 패키지 내에 Logback이 존재하는데, SLF4J(simple logging facade for Java)의 축약어입니다.

2. logger.info(); 로그 메세지를 console에 룰력합니다
 -로깅 수준 종류 : TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 수준이 있습니다 이를 `application.properties`에서 정의합니다 그래서 저희는 아까 `logging.level.root=DEBUG`로 작성했었습니다 TRACE버전의 경우 모든 세부 동작 정보를 다추적하는 상태로, 가장 최상위 수준입니다 default 수준은 INFO에 해당합니다

3. port mumber : 8080입니다. 바꿔서 쓸 수는 있지만(mariaDB는3310으로 편집했습니다), 그대로 두도록하겠습니다
 - 실행 중일 떄 또 실행 버튼 눌러서 터지는 경우가 있습니다 그래서 수업 중에 제가 애플리케이션 정지하라고 하면 미리 정지 하겠ㅅ브니다 안하면 application failed to start메시지가 찍힐겁니다 port 8080 was already in use라는 메시지도 같이 뜰겁니다 몇 번은 제가 수정해주겠지만 일정 시간 지나면 알아서 해결하라고 할 겁니다

 # 의존성 주입(Dependency Injection : DI)
  - 의존성 주입은 구성 요소 간의 느슨한 결합을 이용하여 코드를 유연하고 유지 관리 및 테스트하기 쉽게 만들어주는 요인입니다

  ## 의존성 주입 소개
- 의존성 주입은 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법으로 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지시킴.

- service : 클라이언트가 이용할 수 있는 클래스(의존성)를 의미 - h2database / lombok etc
- client : 의존성을 이용하는 클래스 - Logger를CardatabaseApplication에서 이용했습니다
- Injector : 의존성을 의존클래스에 전달하는 기능담당.

```java
public class Car{
  // field 선언
  private Owner owner;
  //생성자 정의
  public Car(){
    owner - new Owner();
  }
}
```
이상의 코드는 클라이언트 클래스인 Car 가 서비스 클래스인Owner의 객체를 생성하기 때문에 의존성 주입이 없습니다.(즉 직접 생성하기 떄문에 요청 과정이 없습니다)

```java
public class Car{
  private Owner owner;
  public Car(Owner owner){
    this.owner - owner;
  }
}
```

서비스 객체(owner)가 클라이언트 클래스(Car)에서 직접 생성되지 않고, 매개변수로 전달됩니다(즉 CarMain같은 곳에서 owner객체를 생성해서 집어넣어줘야만 합니다).

- 서비스 클래스는 추상 클래스일수도 있습니다 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고 테스트 중에서는 모형(`Mock`)을 이용할 수도 있습니다

- 의존성 주입 방식도 여러 가지 있습니다
1. 생성자 주입(Constructor Injection) : 의존성이 클라이언트 클래스 생성자에 전달되는 방식 아까 위에 적은 방식에 해당합니다 생성자 주입은 필수 의존성에 이용하는 것이 좋습니다

2. 세터 주입(Setter Injection) : 의존성이 세터를 통해 제공되는 방식 예시는 이하와 같습니다

```java
public calss Car{
  private Owner owner;
  public void setOwner(Owner owner){
    this.owner = owner;
  }
  public class CarMain{
    public static void main (String[] args){
      Car car1 = new Car();
      Car car2 = new Car();

      Owner owner1 = new Owner();
      car1.setOwner(owner1);
      car2.setOwner(owner2);
    }
  }
}
```

즉 이상의 코드의 세터 주입은 의존성이 없더라도 일단 객체르 기본 생성자로 만들 수있기 떄문에 더 유연합니다 생성자 주입의 경우 AllArgsConstructor이기 떄문에 일단 Owner가 만들어져야 Car 객체를 만들 수 있겠네요
즉 의존성 주입은 코드 자체의 의존성을 줄이고 코드를 재사용하기 쉽게(car1에도 car2에도 owner을 쓴다는점) 테스트 할  수 있도록 해줍니다

## SpringBoot에서의 의존성 주입 이용

- 스프링 프레임워크에서 의존성 주입은
`ApplicationContext`를 통해서 이루어집니다 이는 객체(bean)와 객체의 의존성을 생성하고 관리하는 역할을 합니다

- 스프링부트는 애플리케이션 클래스를 검색하여 특정 애너테이션(`@Service`, `@Repository`, `@Controller`)이 있는 클래스를 빈으로 등록합니다 의존성 주입을통해 빈을 주입하는게 가능

- 일반적인 방법은 일단 이상에서 배웠던 `생성자주압`입니다

- 객체가 생성될 떄 필요한 모든 의존성을 반드시 이용하게 하므로(AllArgsConstructor니까 빠지만 아예 객체 생성에 실패하겠네요) 가장 권장되는 방식입니다 가장 보편적인 상황은 특정 작업을 위해 데이터베이스에 대한 접근이 필요한 경우겠습니다스피링 부트에서는 DB에 접근하는 클래스를`리포지토리`클래스라고 합니다 이하의 예시를 확인하겠습니다


```java
public class Car{
  private final CarRepository carRepository;

  public Car(CarRepository carRepository){
    this.carRepository = carRepository;
  }
  carRepository.findAll();
}
```

그런데 클래스 생성자가 여러 개 있는 경우에는`@Autowired`애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의 합니다

`세터 주입` : 선택적 의존성인 경우나, 프로그램 실행 중에 의존성 수정하는 경우에 해당합니다
```java
@Service
public class AppUserService{
  private AppUserRepository userRepository;

  @Autowired
  public void  setAppUserRepository
  (AppUserRepository userRepository){
    this.userRepository = userRepositroy;
 }
}
```

`필드주입` : 의존성을 필드에 직접 주입 단순하지만 오류가 발생할 가능성이 높습니다 그리고 테스트용 객체를 별개로 생성할 수가 없어서 테스트 하기도 까다롭다

```java
@Service
public class CarDatabaseService implements
CarServiceP{

}
public class CarController{
  private CarDatabaseSevice
  carDatabaseService = new CarDatabaseService;
}
```
TMl